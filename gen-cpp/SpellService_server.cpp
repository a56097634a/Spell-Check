// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "SpellService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::SpellServer;
//using namespace std;

class SpellServiceHandler : virtual public SpellServiceIf {
 public:
  std::vector<std::string> wordList;
  SpellServiceHandler() {

    // Get the file into stream
    std::ifstream inputStream;
    // This Server is serving shard_0_words for exapm;e
    inputStream.open("shard_0_words");
    std::string word;
    std::string lastline = "";
    
    while(true){
      getline(inputStream, word);
      if(word != lastline){
	//std::cout << word << std::endl;
	wordList.push_back(word);
      }
      else{
	printf("file loaded\n");
	break;
      }
    }
  }

  void spellcheck(SpellResponse& _return, const SpellRequest& request) {
    // Your implementation goes here
    //sleep(2);
    printf("spellcheck\n");
    //Get the word from request
    std::vector<std::string> buffer = request.to_check;

    //check every word using vector
    for(std::vector<std::string>::iterator i = buffer.begin(); i != buffer.end(); i++){
      std::string toCheck = (*i);
      //std::cout << toCheck << std::endl;
      for(std::vector<std::string>::iterator it = wordList.begin(); it != wordList.end(); it++){
	if((*it) == toCheck){
	  _return.is_correct.push_back(true);
	  break;
	}
	if(it == (wordList.end()-1)){
	  _return.is_correct.push_back(false);
	}
      }
    }
  }  
};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<SpellServiceHandler> handler(new SpellServiceHandler());
  shared_ptr<TProcessor> processor(new SpellServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port, 1000, 1000));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    try {
        server.serve();
    } catch (TTransportException &e) {
        printf("server error...closing server...\n");
    }
  return 0;
}

